import streamlit as st
import requests
import json
from enum import Enum

from utils.helpers import (
    fetch_nominal_compositions,
    fetch_nominal_composition_exploration_jobs,
    AIRFLOW_API_URL,
    GeometricTransformations,
)

##########################################################################
#
# Globals
#
##########################################################################


##########################################################################
#
# Helpers
#
##########################################################################


# Session state attributes initialization
def initialize_session_state(st):

    if "selected_nc" not in st.session_state:
        st.session_state.selected_nc = None

    if "selected_run_id" not in st.session_state:
        st.session_state.selected_run_id = None

    if "nc_runs_subruns_from_db" not in st.session_state:
        st.session_state.nc_runs_subruns_from_db = None

    if "selected_sub_runs" not in st.session_state:
        st.session_state.selected_sub_runs = {}


# Check if a given Run has a specific SubRun
def get_scheduled_sub_run_numbers(runs, run_number):

    for run in runs:
        if run["run_number"] == run_number:
            return [sub_run["sub_run_number"] for sub_run in run["sub_runs"]]

    return []


# Lookup Geometric Transformation label
def get_gt_label_by_index(target_index: int) -> str:
    for transformation in GeometricTransformations:
        if transformation.index == target_index:
            return transformation.label
    return None


##########################################################################
#
# Streamlit actions and rendering
#
##########################################################################

# TODO: review the code (behavior not working as expected)
# TODO: load the state of all runs and sub-runs in the DB when user changes a NCs

st.set_page_config(page_title="Pre-Deployment Exploitation DAG", layout="centered")
st.title("Pre-Deployment Exploitation DAG")

# Session state attributes initialization
initialize_session_state(st)

# Drop-down for Nominal Composition (NC) selection
all_ncs = fetch_nominal_compositions(st)
selected_nc = st.selectbox("Select a Nominal Composition", [c["name"] for c in all_ncs])


# Reset session flags and cached data for NC, Run, and SubRuns (transformations)
# Also querying all Runs and Subruns for the selected NC
changed_nc = selected_nc != st.session_state.selected_nc

if changed_nc:  # When a different NC was selected in the drop-down
    st.session_state.selected_nc = selected_nc
    st.session_state.selected_run_id = None
    st.session_state.nc_runs_subruns_from_db = (
        fetch_nominal_composition_exploration_jobs(selected_nc, True, st)
    )
    st.session_state.selected_sub_runs.clear()

#
# Inputs
#
##########################################################################
if selected_nc:

    if st.session_state.nc_runs_subruns_from_db:  # If the NC has scheduled Runs

        # Configuring the drop-down with Runs and getting the id of the selected Run
        conv_run_number_to_id = {
            f"Run {r['run_number']}": r["id"]
            for r in st.session_state.nc_runs_subruns_from_db
        }

        runs_labels = list(conv_run_number_to_id.keys())

        selected_run_label = st.selectbox(
            "Select a Nominal Composition Exploration Run", runs_labels
        )

        selected_run_id = conv_run_number_to_id[selected_run_label]

        # Update session state for selected run
        changed_run = selected_run_id != st.session_state.selected_run_id

        if changed_run:
            st.session_state.selected_run_id = selected_run_id

        # List of all transformation options
        all_gtransf_options = list(GeometricTransformations)

        # The set of checkboxes with transformations
        st.markdown("Selected Exploit (augmentation) Geometric Transformations:")

        selected_sub_runs = []

        if selected_run_id in st.session_state.selected_sub_runs:
            already_selected_sub_runs = st.session_state.selected_sub_runs[
                selected_run_id
            ]
        else:
            already_selected_sub_runs = []

        already_scheduled_sub_runs = get_scheduled_sub_run_numbers(
            st.session_state.nc_runs_subruns_from_db,
            selected_run_id,
        )

        with st.container():

            # Otherwise, show individual checkboxes
            for transf in all_gtransf_options:

                key = f"{transf.name}_{selected_run_id}"  # Unique key per run

                # the checkbox is checked if it is a Run that has only the SubRun 0
                # or if it is already scheduled in the back-end or if it was
                # already selected before between changes in the Run drop-down
                is_checked = (
                    (
                        already_selected_sub_runs == []
                        and already_scheduled_sub_runs == [0]
                    )
                    or transf.index in already_selected_sub_runs
                    or transf.index in already_scheduled_sub_runs
                )

                # is disabled if it is already scheduled in the back-end
                is_disabled = transf.index in already_scheduled_sub_runs

                checked_transf = st.checkbox(
                    transf.label,
                    key=key,
                    value=is_checked,
                    disabled=is_disabled,
                )

                if checked_transf:
                    selected_sub_runs.append(transf.index)

        # Store the selected transformations for this run
        st.session_state.selected_sub_runs[selected_run_id] = selected_sub_runs

        #
        # The warning message with a summary of Exploitation (augmentation)
        # Runs that will be triggered.
        #
        ##########################################################################

        runs_ids = list(conv_run_number_to_id.values())

        gt_runs_to_trigger = {}
        for run_id in runs_ids:

            already_scheduled_sub_runs = get_scheduled_sub_run_numbers(
                st.session_state.nc_runs_subruns_from_db,
                run_id,
            )

            gt_runs_to_trigger[run_id] = list(
                set(st.session_state.selected_sub_runs[run_id])
                - set(already_scheduled_sub_runs)
                if run_id in st.session_state.selected_sub_runs
                and already_scheduled_sub_runs
                else []
            )

        has_gt_runs_to_trigger = any(
            isinstance(v, list) and len(v) > 0 for v in gt_runs_to_trigger.values()
        )

        if has_gt_runs_to_trigger:

            str_warning = f"""##### ⚠️ Important Warning\nIf you click on **Trigger DAG**, that action will apply to all the following **Exploit (augmentation) Geometric Transformations**:"""

            for run_id, gt_runs in gt_runs_to_trigger.items():

                if not gt_runs:
                    continue

                str_warning += f"\n- Run {run_id}:"

                for gt_run in gt_runs:
                    str_warning += f"\n  - {get_gt_label_by_index(gt_run)}"

            st.warning(str_warning)

        #
        # The action button to trigger the Airflow DAG
        #
        ##########################################################################
        if has_gt_runs_to_trigger and st.button("Trigger DAG"):

            st.success(f"✅ Submitted.")

            dag_id = "pre_deployment_exploitation"  # TODO: shouldn't be hardcoded

            api_conf = []  # TODO: must be like:
            # { "runs": [
            #   {
            #     "id": 1,
            #     "run_number": 1,
            #     "sub_runs": [1,2,3,4,5]
            #   },
            #   {
            #     "id": 2,
            #     "run_number": 2,
            #     "sub_runs": [6,7,13,14]
            #   }
            # ]}

            # TODO: Don’t expose Airflow REST API directly to Streamlit; instead, let FastAPI to proxy that.
            #   Keep Streamlit UI-only. All logic (even triggering pipelines) should be routed via FastAPI.
            response = requests.post(
                f"{AIRFLOW_API_URL}/api/v1/dags/{dag_id}/dagRuns",
                auth=("admin", "admin"),
                json={"conf": api_conf},
            )

            # TODO: even when a specific DAG Task fails, it will return 200 since
            #   the DAG was triggered successfully.
            if response.status_code == 200:
                st.success("DAG triggered successfully!")
            else:
                st.error(f"Failed: {response.text}")

    else:
        st.write(f"No Exploration Runs for Nominal Composition {selected_nc}")
